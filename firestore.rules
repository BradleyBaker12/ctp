// Firestore rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Public vehicle listings (readable by anyone)
    match /vehicles/{vehicleId} {
      allow read: if true;
      allow write: if request.auth != null && (
        // Owner can write their own vehicle
        request.auth.uid == resource.data.userId ||
        // Admins can write any vehicle
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userRole in ['admin', 'sales representative'] ||
        // OEM users (manager or employee) can write vehicles owned by their company
        (
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userRole == 'oem' &&
          (
            // Prefer explicit ownerCompanyId match if present
            (
              resource.data.ownerCompanyId is string &&
              resource.data.ownerCompanyId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.companyId
            ) ||
            // Fallback: compare owner's company
            (
              get(/databases/$(database)/documents/users/$(resource.data.userId)).data.companyId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.companyId
            )
          )
        )
      );
      // Subcollections (e.g., tyres, truckConditions)
      match /{subCollection=**}/{docId} {
        allow read: if true;
        allow write: if request.auth != null;
      }
    }

    // User profiles (user can read/write their own, admins can read/write all)
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        request.auth.uid == userId ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userRole in ['admin', 'sales representative']
      );
    }

    // Offers (readable by involved users and admins, writable by involved users)
    match /offers/{offerId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && (
        (
          // Dealer, transporter, or admin can update general fields (not acceptance)
          request.auth.uid == resource.data.dealerId ||
          request.auth.uid == resource.data.transporterId ||
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userRole in ['admin', 'sales representative'] ||
          // For setting offerStatus to 'accepted', allow OEM manager of vehicle owner's company
          (
            request.resource.data.offerStatus == 'accepted' &&
            resource.data.offerStatus != 'accepted' &&
            // Look up vehicle owner company
            (
              // Get the vehicle doc
              (
                // Resolve vehicle company via explicit field
                (
                  get(/databases/$(database)/documents/vehicles/$(resource.data.vehicleId)).data.ownerCompanyId is string &&
                  get(/databases/$(database)/documents/vehicles/$(resource.data.vehicleId)).data.ownerCompanyId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.companyId
                ) ||
                // Fallback via vehicle.userId -> users.companyId
                (
                  get(/databases/$(database)/documents/users/$(get(/databases/$(database)/documents/vehicles/$(resource.data.vehicleId)).data.userId)).data.companyId == get(/databases/$(database)/documents/users/$(request.auth.uid)).data.companyId
                )
              ) &&
              // And the acting user is OEM manager
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userRole == 'oem' &&
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isOemManager == true
            )
          )
        )
        && (
          // If updating POP fields, require an admin invoice to exist
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['proofOfPaymentUrl', 'proofOfPaymentFileName', 'uploadTimestamp'])
          || (
            (resource.data.externalInvoice is string && resource.data.externalInvoice.size() > 0) ||
            (resource.data.externalInvoiceUrl is string && resource.data.externalInvoiceUrl.size() > 0) ||
            (resource.data.invoiceUrl is string && resource.data.invoiceUrl.size() > 0) ||
            (resource.data.sageInvoiceUrl is string && resource.data.sageInvoiceUrl.size() > 0) ||
            (resource.data.invoicePdfUrl is string && resource.data.invoicePdfUrl.size() > 0) ||
            (resource.data.invoiceDownloadUrl is string && resource.data.invoiceDownloadUrl.size() > 0)
          )
        )
      );

      // Backstop: Only allow dealer to upload POP when an admin invoice exists on the offer
      allow update: if request.auth != null && request.resource.data.diff(resource.data).affectedKeys().hasAny(['proofOfPaymentUrl', 'proofOfPaymentFileName', 'uploadTimestamp'])
        && (
          // Must be dealer
          request.auth.uid == resource.data.dealerId
        )
        && (
          // Require one of the known invoice fields to exist and be non-empty
          (
            (resource.data.externalInvoice is string && resource.data.externalInvoice.size() > 0) ||
            (resource.data.externalInvoiceUrl is string && resource.data.externalInvoiceUrl.size() > 0) ||
            (resource.data.invoiceUrl is string && resource.data.invoiceUrl.size() > 0) ||
            (resource.data.sageInvoiceUrl is string && resource.data.sageInvoiceUrl.size() > 0) ||
            (resource.data.invoicePdfUrl is string && resource.data.invoicePdfUrl.size() > 0) ||
            (resource.data.invoiceDownloadUrl is string && resource.data.invoiceDownloadUrl.size() > 0)
          )
        );
    }

    // Notifications (written by app, processed by backend)
    match /direct_push_notifications/{notificationId} {
      allow create: if request.auth != null;
      allow read, update, delete: if false;
    }
  }
}